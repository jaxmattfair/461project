#!/bin/bash

#set -e  # Exit immediately if a command exits with a non-zero status

# Function to load environment variables
load_env() {
    if [ -f .env ]; then
        export $(grep -v '^#' .env | xargs)
    else
        echo "Error: .env file not found" >&2
        exit 1
    fi
}

# Function to check if log file exists and create it if not
setup_log_file() {
    if [ -z "$LOG_FILE" ]; then
        echo "Error: LOG_FILE environment variable not set" >&2
        exit 1
    fi

    # Set default log level if LOG_LEVEL is not set
    if [ -z "$LOG_LEVEL" ]; then
        LOG_LEVEL="INFO"
    fi
    
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE" || { echo "Error: Unable to create log file at $LOG_FILE" >&2; exit 1; }
    # Ensure LOG_LEVEL is a valid log level
    case "$LOG_LEVEL" in
        0|1|2) ;;
        *)
            echo "Error: Invalid LOG_LEVEL value. Must be one of: DEBUG, INFO, WARN, ERROR" >&2
            exit 1
            ;;
    esac
}

# Function to log messages
log() {
    local level="$1"
    shift
    local message="$*"

    # Array to define the log level priority
    declare -A log_priority=( [DEBUG]=1 [INFO]=2 [WARN]=3 [ERROR]=4 )

    # Only log messages that are equal or higher than the current LOG_LEVEL
    if [ ${log_priority[$level]} -ge ${log_priority[$LOG_LEVEL]} ]; then
        echo "$(date +"%Y-%m-%d %H:%M:%S") [$level]: $message" >> "$LOG_FILE"
    fi
}

# Function to install dependencies
install_dependencies() {
    log "Starting installation of dependencies"
    if ! npm install; then
        log "Error: npm install failed"
        exit 1
    fi
    local installed_count=$(npm ls --json | jq '.dependencies | length')
    echo "$installed_count dependencies installed..."
    log "Finished installation of dependencies"
}

# Function to rank modules
rank_modules() {
    local url_file="$1"
    log "Starting module ranking for URLs in $url_file"

    while IFS= read -r url || [[ -n "$url" ]]; do
        log "Processing URL: $url"

        # Check if the URL is a valid GitHub or npm URL
        result=$(node -e "
            (async () => {
                try {
                    const { getGitHubUrlFromNpm, isGitHubUrl } = await import('./dist/src/utils/npmUtils.js');
                    const { URL } = await import('url');

                    const inputUrl = '$url';
                    let repoUrl = inputUrl;  // Ensure we start fresh with each URL

                    if (isGitHubUrl(repoUrl)) {
                        console.log(repoUrl);
                    }
                    // Check if it's an npm URL (assumes npm URLs contain 'npmjs.com/package')
                    else if (inputUrl.includes('npmjs.com/package')) {
                        const gitHubUrl = await getGitHubUrlFromNpm(inputUrl);
                        if (gitHubUrl == 'null') {
                            console.error('Invalid npm package or no GitHub repository found');
                            process.exit(1);
                        }
                        repoUrl = gitHubUrl;
                        console.log(repoUrl);
                    } else {
                        // If the URL is not from npm, check if it's a valid GitHub URL
                        if (!isGitHubUrl(repoUrl)) {
                            //console.error('Not a valid github url?')
                            //console.error('Error: Invalid URL. Must be a valid npm package URL or GitHub repository URL.');
                            console.log('');
                            process.exit(1);
                        }
                    }

                    // Output the valid GitHub URL for further processing
                } catch (error) {
                    //console.error('Error processing URL:', error.message);
                    process.exit(1);
                }
            })();
        " 2>&1)

        if [[ $? -ne 0 ]]; then
            log "Error: Invalid URL or no GitHub repository found for $url"
            exit 1
        fi

        log "Valid GitHub URL: $result"

        # Create a temporary directory for cloning the repository
        temp_dir=$(mktemp -d)
        log "Created temporary directory: $temp_dir"

        log "Calculating metrics for $result"

        # Run the calculateNetScore.js script via Node.js
        metrics=$(node -e "
            (async () => {
                try {
                    const { calculateNetScore } = await import('./dist/src/metrics/netScore.js');
                    const tempDir = '${temp_dir}';
                    const repoURL = '$result';

                    const result = await calculateNetScore(repoURL, tempDir);
                    process.stdout.write(JSON.stringify(result));
                } catch (error) {
                    process.stderr.write('Error calculating metrics: ' + error.message + '\\n');
                }
            })();
        " 2>&1)

        log "Result: $metrics"
        # Check if result is empty
        if [[ -z "$metrics" ]]; then
            log "Error calculating scores for URL: $url"
            exit 1
        fi

        # Parse the JSON result and extract individual fields
        net_score=$(echo "$metrics" | jq -r '.NetScore // -1')
        net_score_latency=$(echo "$metrics" | jq -r '.NetScore_Latency // -1')
        ramp_up=$(echo "$metrics" | jq -r '.RampUp // -1')
        ramp_up_latency=$(echo "$metrics" | jq -r '.RampUp_Latency // -1')
        correctness=$(echo "$metrics" | jq -r '.Correctness // -1')
        correctness_latency=$(echo "$metrics" | jq -r '.Correctness_Latency // -1')
        bus_factor=$(echo "$metrics" | jq -r '.BusFactor // -1')
        bus_factor_latency=$(echo "$metrics" | jq -r '.BusFactor_Latency // -1')
        responsive_maintainer=$(echo "$metrics" | jq -r '.ResponsiveMaintainer // -1')
        responsive_maintainer_latency=$(echo "$metrics" | jq -r '.ResponsiveMaintainer_Latency // -1')
        license=$(echo "$metrics" | jq -r '.License // -1')
        license_latency=$(echo "$metrics" | jq -r '.License_Latency // -1')

        # Output the extracted values for debugging
        log "NetScore: $net_score"
        log "NetScore_Latency: $net_score_latency"
        log "RampUp: $ramp_up"
        log "RampUp_Latency: $ramp_up_latency"
        log "Correctness: $correctness"
        log "Correctness_Latency: $correctness_latency"
        log "BusFactor: $bus_factor"
        log "BusFactor_Latency: $bus_factor_latency"
        log "ResponsiveMaintainer: $responsive_maintainer"
        log "ResponsiveMaintainer_Latency: $responsive_maintainer_latency"
        log "License: $license"
        log "License_Latency: $license_latency"

        # Clean up the temporary directory
        rm -rf "$temp_dir"
        log "Removed temporary directory: $temp_dir"

    done < "$url_file"

    log "Finished module ranking."
}




# Function to run tests
run_tests() {
    log "Starting test execution"
    test_output=$(npm test 2>&1)
    total_tests=$(echo "$test_output" | grep -oP 'Total: \K\d+' || echo "N/A")
    passed_tests=$(echo "$test_output" | grep -oP 'Passed: \K\d+' || echo "N/A")
    coverage=$(echo "$test_output" | grep -oP 'Coverage: \K\d+' || echo "N/A")
    echo "Total: $total_tests"
    echo "Passed: $passed_tests"
    echo "Coverage: $coverage%"
    echo "$passed_tests/$total_tests test cases passed. $coverage% line coverage achieved."
    log "Finished test execution"
}

# Main execution
load_env
setup_log_file

case "$1" in
    install)
        install_dependencies
        ;;
    test)
        run_tests
        ;;
    *)
        if [ -f "$1" ]; then
            rank_modules "$1"
        else
            echo "Usage: $0 {install|test|<path_to_url_file>}" >&2
            exit 1
        fi
        ;;
esac

exit 0
