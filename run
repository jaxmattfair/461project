#!/bin/bash

set -e  # Exit immediately if a command exits with a non-zero status

# Function to load environment variables
load_env() {
    if [ -f .env ]; then
        export $(grep -v '^#' .env | xargs)
    else
        echo "Error: .env file not found" >&2
        exit 1
    fi
}

# Function to check if log file exists and create it if not
setup_log_file() {
    if [ -z "$LOG_FILE" ]; then
        echo "Error: LOG_FILE environment variable not set" >&2
        exit 1
    fi
    
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE" || { echo "Error: Unable to create log file at $LOG_FILE" >&2; exit 1; }
}

# Function to log messages
log() {
    echo "$(date +"%Y-%m-%d %H:%M:%S"): $1" >> "$LOG_FILE"
}

# Function to install dependencies
install_dependencies() {
    log "Starting installation of dependencies"
    npm install
    local installed_count=$(npm ls --json | jq '.dependencies | length')
    echo "$installed_count dependencies installed..."
    log "Finished installation of dependencies"
}

# Function to rank modules
rank_modules() {
    local url_file="$1"
    log "Starting module ranking for URLs in $url_file"
    
    output_file="output.ndjson"
    > "$output_file"
    
    while IFS= read -r url || [[ -n "$url" ]]; do
        log "Processing URL: $url"
        
        temp_dir=$(mktemp -d)
        log "Created temporary directory: $temp_dir"
        
        log "Calculating metrics for $url"
        result=$(NODE_OPTIONS="--loader ts-node/esm" ts-node --esm -e "
            import { calculateNetScore } from './src/metrics/netScore.ts';
            import { parseGitHubRepoURL, getReadmeContent, parseMarkdown } from './src/utils/gitUtils.ts';
            import { analyzeReadme, calculateRampUpScore } from './src/metrics/rampUpScore.ts';
            
            (async () => {
                try {
                    const scores = await calculateNetScore('$url', '$temp_dir');
                    const parsed = parseGitHubRepoURL('$url');
                    const readmeContent = getReadmeContent('$temp_dir');
                    if (readmeContent) {
                        const ast = parseMarkdown(readmeContent);
                        const metrics = analyzeReadme(ast);
                        scores.rampUpScore = calculateRampUpScore(metrics);
                    }
                    console.log(JSON.stringify(scores));
                } catch (e) {
                    console.error('Error:', e instanceof Error ? e.message : 'Unknown error occurred');
                }
            })();
        " 2>&1) || { log "Error calculating scores: $result"; result='{}'; }
        
        # Parse the JSON result
        net_score=$(echo "$result" | jq -r '.netScore // -1')
        bus_factor=$(echo "$result" | jq -r '.busFactorScore // -1')
        correctness=$(echo "$result" | jq -r '.correctnessScore // -1')
        ramp_up=$(echo "$result" | jq -r '.rampUpScore // -1')
        responsive_maintainer=$(echo "$result" | jq -r '.responsiveMaintainerScore // -1')
        license=$(echo "$result" | jq -r '.licenseScore // -1')
        
        log "Attempting to write results to $output_file"
        echo "{\"URL\":\"$url\", \"NetScore\":$net_score, \"RampUp\":$ramp_up, \"Correctness\":$correctness, \"BusFactor\":$bus_factor, \"ResponsiveMaintainer\":$responsive_maintainer, \"License\":$license}" >> "$output_file"
        log "Successfully wrote results for $url to $output_file"
        
        rm -rf "$temp_dir"
        log "Removed temporary directory: $temp_dir"
    done < "$url_file"
    
    log "Finished module ranking. Results saved to $output_file."
    
    if [[ -s "$output_file" ]]; then
        log "Output file $output_file is not empty"
    else
        log "Warning: Output file $output_file is empty"
        echo "Warning: Output file $output_file is empty" >&2
    fi
}
   

# Function to run tests
run_tests() {
    log "Starting test execution"
    test_output=$(npm test 2>&1)
    total_tests=$(echo "$test_output" | grep -oP 'Total: \K\d+' || echo "N/A")
    passed_tests=$(echo "$test_output" | grep -oP 'Passed: \K\d+' || echo "N/A")
    coverage=$(echo "$test_output" | grep -oP 'Coverage: \K\d+' || echo "N/A")
    echo "Total: $total_tests"
    echo "Passed: $passed_tests"
    echo "Coverage: $coverage%"
    echo "$passed_tests/$total_tests test cases passed. $coverage% line coverage achieved."
    log "Finished test execution"
}

# Main execution
load_env
setup_log_file

case "$1" in
    install)
        install_dependencies
        ;;
    test)
        run_tests
        ;;
    *)
        if [ -f "$1" ]; then
            rank_modules "$1"
        else
            echo "Usage: $0 {install|test|<path_to_url_file>}" >&2
            exit 1
        fi
        ;;
esac

exit 0
